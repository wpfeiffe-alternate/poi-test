package controllers;


import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

import javax.servlet.ServletException;
import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;

/**
 * Servlet will return a local file for the supported file types (PDF, XLS, HTML, etc...)<P>
 * This servlet assumes that the following attributes are set: <P>
 *
 * filePath - path to file to serve up <br>
 * fileType - the type of the file
 *
 * @web.servlet name="FileServlet"
 * @web.servlet-mapping
 *              url-pattern="/GetFile"
 */
@Controller
public class FileController
{
    /**
     *
     */
    private static final long serialVersionUID = 1L;

    private static final AFLogger log = AFLogger.getLogger(FileController.class);

    /**
     * handle the servlet doGet method and pass to doWork
     *
     * @param  req standard servlet request object
     * @param  resp standard servlet response object
     * @exception  ServletException  servlet defined exception
     * @exception  IOException  servlet defined exception
     */
    @GetMapping(value = "/getFile")
    protected void getFile(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException
    {
        try
        {
            doWork(req, resp);
        }
        catch (Exception e)
        {
            resp.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
            log.error("Error occurred while retrieving the file", e);
        }
    }

    /**
     * Handles the retrieval of a local file and returns it to the browswer.  Designed to handle the following
     * types: <P/>
     *
     * PDF <br>
     * HTML <br>
     * XLS <br>
     * PSR <P/>
     *
     * This servlet expects the following attributes to be set on the request: <P>
     *
     * filePath - path to file to serve up <br>
     * fileType - the type of the file
     *
     * @param  req standard servlet request object
     * @param  resp standard servlet response object
     * @exception  ServletException  servlet defined exception
     * @exception  IOException  servlet defined exception
     */

    protected void doWork(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException

    {
        String filePath 	= "ERROR";
        OutputStream fileOut = null;
        String fileType 	= "ERROR";
        String deleteFile   = null;
        String fileName   = null;

        resp.setHeader("Pragma", "");
        resp.setHeader("Cache-control", "");

        try
        {
            // get the path and type
            filePath = (String) req.getAttribute("filePath");
            fileType = (String) req.getAttribute("fileType");
            deleteFile = (String) req.getAttribute("deleteFile");
            fileName = (String) req.getAttribute("fileName" );

            // validations
            if (filePath == null || !Files.exists(Paths.get(filePath)) || fileType == null)
            {
                throw new ServletException("Invalid parameters provided");
            }

            String localFilePath = filePath;

            Path localPath = Sanitizer.createSanitizedPath(localFilePath);

            // set the content to return the mime type of the provided file type
            resp.setContentType(Sanitizer.sanitizeCrLfAndHtmlBasic(getMimeType(fileType)));

            // set the length of the return to filesize
            resp.setContentLength((int) Files.size(localPath));

            // set the filename to use
            if(fileName != null && !fileName.isEmpty())
            {
                resp.setHeader("Content-disposition", "attachment; filename=" + Sanitizer.sanitizeCrLfAndHtmlBasic(fileName));
            }

            // get the output stream
            fileOut = resp.getOutputStream();

            Files.copy(localPath, fileOut);
            fileOut.flush();

            //check if we are deleting the file
            if (deleteFile != null && (deleteFile.equalsIgnoreCase("Y") || deleteFile.equalsIgnoreCase("true")))
            {
                Files.deleteIfExists(localPath);
            }

        } //end try
        catch (FileNotFoundException fnfex)
        {
            resp.setContentType("text/html");
            ServletOutputStream textOut = resp.getOutputStream();
            textOut.println("File Not Found");
            log.error("FileNotFoundException", fnfex);
        }
        catch (IOException e)
        {
            log.error("IOException", e);
        }
        catch (Exception e)
        {
            log.error("Exception: " + e);
        } //end catch

        finally
        {
            // make sure both are closed (multiple calls OK with IOUtils.closeQuietly)
            IOUtils.closeQuietly(fileOut);
        }
    }

    /**
     * Returns the supported mime type for the given file type
     *
     * @param  fileType The file type for which a mime type will be returned
     * @return  mime type for the given file type to be returned in servlet
     */
    protected String getMimeType(String fileType)
    {
        String retString = "text/html";

        // strip a leading dot to account for file extensions having them
        if (fileType.startsWith("."))
        {
            fileType = fileType.substring(1);
        }

        if (fileType.equalsIgnoreCase("PDF"))
        {
            retString = "application/pdf";
        }
        else if (fileType.equalsIgnoreCase("PSR"))
        {
            retString = "application/pdf";
        }
        else if (fileType.equalsIgnoreCase("STD"))
        {
            retString = "application/pdf";
        }
        else if (fileType.equalsIgnoreCase("XLS"))
        {
            retString = "application/xls";
        }
        else if (fileType.equalsIgnoreCase("XLSX"))
        {
            retString = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
        }
        else if (fileType.equalsIgnoreCase("CSV"))
        {
            retString = "text/csv";
        }
        else if (fileType.equalsIgnoreCase("HTML"))
        {
            retString = "text/html";
        }
        else if (fileType.equalsIgnoreCase("DOC"))
        {
            retString = "application/word";
        }
        else if (fileType.equalsIgnoreCase("XML"))
        {
            retString = "application/xml";
        }
        else if (fileType.equalsIgnoreCase("TXT"))
        {
            retString = "text/text";
        }
        else if(fileType.equalsIgnoreCase("TIFF") ||
                fileType.equalsIgnoreCase("TIF") ||
                fileType.equalsIgnoreCase("PNG") ||
                fileType.equalsIgnoreCase("JPG") ||
                fileType.equalsIgnoreCase("JPEG") ||
                fileType.equalsIgnoreCase("GIF") ||
                fileType.equalsIgnoreCase("BMP"))
        {
            retString = "image/" + fileType.toLowerCase();
        }
        else if (fileType.equalsIgnoreCase("ZIP"))
        {
            retString = "application/zip";
        }
        return retString;
    }
}
package controllers;

import org.springframework.http.ResponseEntity;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.access.annotation.Secured;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@Controller
@RequestMapping("/view/file")
public class JobRunViewFileController  {

    private final DataExportJobRunRepository jobRunRepository;

    public JobRunViewFileController(DataExportJobRunRepository jobRunRepository) {
        this.jobRunRepository = jobRunRepository;
    }

    @GetMapping("export")
    @Secured("ROLE_DATA_EXPORT_VIEW")
    void viewExportFile(@RequestParam("jobRunId") Long jobRunId,
                        HttpServletRequest request,
                        HttpServletResponse response) throws Exception {

        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        AuthUser details = (AuthUser) authentication.getPrincipal();

        DataExportJobRun jobRun = jobRunRepository.findById(jobRunId).orElseThrow(()-> new Exception("ID not found"));
        if (!jobRun.getDataExportCompanySchedule().getCocode().equals(details.getCocode()) &&
                !details.isAfUser()) {
            throw new AccessDeniedException("Access denied");
        }

        request.setAttribute("deleteFile", "N");
        request.setAttribute("filePath", jobRun.getOutputFile());
        request.setAttribute("fileName", jobRun.getDataExportCompanySchedule().getDataExportJobDef().getJobName() + "." +
                jobRun.getDataExportCompanySchedule().getExportFormat());
        request.setAttribute("fileType", jobRun.getDataExportCompanySchedule().getExportFormat());
        request.getRequestDispatcher("/getFile").forward(request, response);
    }

}
